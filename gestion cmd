
on creer ac - 3 pipes (-3 pour le programme path, le nom du fichier d'entree, le nom du fichier de sortie)

en recursif

routine_child(int fdin, int fdout, char **cmd, char **env)
{
	dup2(fdin, stdin)
	dup2(fdout, stdout)
	excve(cmd[0], cmd, env)
	exit(perror(FAILURE), errno)
}

get_path(char **env, char *cmd)
{
	char	**listpath
	char	*dpath
	char	*fpath
	char	**temp;

	while (*env && ft_strncmp(*env), "PATH=", 5)
		env++
	if (!*env)
		return (NULL);
	listpath = ft_split((*env) + 5, ':')
	temp = listpath
	while (*listpath)
	{
		dpath = ft_strjoin(*listpath, "/")
		fpath = ft_strjoin(path, cmd)
		free(dpath)
		if (!access(path))
			break ;
		free(fpath)
		free(*listpath)
		listpath++
	}
	while (*listpath)
		free(*listpath++)
	return (free(temp), fpath);
}

create_cmd(char *cmd, char **env)
{
	cmd = ft_split(av)
	exe = getpath(cmd[0], env
	free(cmd[0])
	cmd[0] = exe 
}

int funct(char **av, char **env, int nb, int infile)
{
	int pip[2]
	t_pid pid
	char **cmd

	if (pipe(pip))
		return (perror(pipe), -1);
	cmd = create_cmd(*av, env);
	pid = fork
	if (pid == -1)
		return (tabclear(cmd), -1)
	if (!pid) //child
	{
		close(pip[1])
		routine_child(infile, pip[0], cmd, env)
	}
	dup2(infile, stdin)
	close(pip[1])
	if (pid > 0)
		waitpid(pid)
	if (nb && *(++av))
		return (tabclear(cmd), funct(av, env, nb - 1, pip[0]));
	if (!nb)
		return (tabclear(cmd), pid[0])
	close(pip[0])
	return (tabclear(cmd), -1)
}


cmd doit etre creer avant le fork (pour pouvoir le free apres)
